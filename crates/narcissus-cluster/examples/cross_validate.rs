//! Cross-validate narcissus-cluster against tslearn (Python) reference data.
//!
//! Reads `cross_val/reference.json` (generated by `cross_val/generate_references.py`)
//! and compares our K-means results against tslearn's ground truth.
//!
//! Run:
//!   cargo run --example cross_validate -p narcissus-cluster
//!
//! Generate reference data first:
//!   cd cross_val && uv run generate_references.py

use std::collections::HashMap;
use std::fs;

use serde::Deserialize;

use narcissus_cluster::{KMeansConfig, OptimizeConfig};
use narcissus_dtw::{BandConstraint, DbaConfig, TimeSeries};

// ── JSON schema matching reference.json ─────────────────────────────────────

#[derive(Deserialize)]
struct Reference {
    series: Vec<Vec<f64>>,
    dba_centroids: HashMap<String, Vec<f64>>,
    kmeans_k3: KmeansK3,
    kmeans_k1: KmeansK1,
    kmeans_k9: KmeansK9,
    elbow: Vec<ElbowEntry>,
}

#[derive(Deserialize)]
struct KmeansK3 {
    inertia: f64,
    partition: HashMap<String, Vec<usize>>,
}

#[derive(Deserialize)]
struct KmeansK1 {
    inertia: f64,
    centroid: Vec<f64>,
}

#[derive(Deserialize)]
struct KmeansK9 {
    inertia: f64,
}

#[derive(Deserialize)]
struct ElbowEntry {
    k: usize,
    inertia: f64,
}

// ── Helpers ─────────────────────────────────────────────────────────────────

fn load_reference() -> Reference {
    let path = concat!(env!("CARGO_MANIFEST_DIR"), "/../../cross_val/reference.json");
    let data = fs::read_to_string(path).expect("cross_val/reference.json not found — run generate_references.py first");
    serde_json::from_str(&data).expect("failed to parse reference.json")
}

fn build_series(raw: &[Vec<f64>]) -> Vec<TimeSeries> {
    raw.iter()
        .map(|v| TimeSeries::new(v.clone()).unwrap())
        .collect()
}

/// Extract the partition as a set of sorted index groups, ignoring label numbering.
///
/// Two clusterings are equivalent if they produce the same partition of indices,
/// regardless of which numeric label each cluster gets.
fn partition_groups(assignments: &[usize]) -> Vec<Vec<usize>> {
    let mut groups: HashMap<usize, Vec<usize>> = HashMap::new();
    for (i, &label) in assignments.iter().enumerate() {
        groups.entry(label).or_default().push(i);
    }
    let mut result: Vec<Vec<usize>> = groups.into_values().collect();
    for g in &mut result {
        g.sort();
    }
    result.sort();
    result
}

fn check(name: &str, pass: bool, detail: &str) {
    if pass {
        println!("  PASS  {name}: {detail}");
    } else {
        println!("  FAIL  {name}: {detail}");
    }
}

// ── Main ────────────────────────────────────────────────────────────────────

fn main() {
    let ref_data = load_reference();
    let series = build_series(&ref_data.series);
    let n = series.len();

    let mut n_pass = 0u32;
    let mut n_fail = 0u32;

    let mut check_and_count = |name: &str, pass: bool, detail: &str| {
        check(name, pass, detail);
        if pass {
            n_pass += 1;
        } else {
            n_fail += 1;
        }
    };

    // ── 1. DBA centroid comparison ──────────────────────────────────────────

    println!("\n=== DBA centroid comparison ===");

    let groups: [(& str, &[usize]); 3] = [
        ("group_0", &[0, 1, 2]),
        ("group_1", &[3, 4, 5]),
        ("group_2", &[6, 7, 8]),
    ];

    let dba_config = DbaConfig::new(BandConstraint::Unconstrained)
        .with_max_iter(50)
        .with_tol(1e-8);

    for (name, indices) in &groups {
        let views: Vec<_> = indices.iter().map(|&i| series[i].as_view()).collect();
        let result = dba_config.average(&views).unwrap();
        let rust_centroid: &[f64] = result.centroid.as_ref();

        let py_centroid = ref_data.dba_centroids.get(*name).unwrap();

        let max_diff: f64 = rust_centroid
            .iter()
            .zip(py_centroid)
            .map(|(a, b)| (a - b).abs())
            .fold(0.0f64, f64::max);

        let pass = max_diff < 1e-6;
        check_and_count(
            &format!("DBA {name}"),
            pass,
            &format!("max_diff={max_diff:.2e} (rust={rust_centroid:.6?}, py={py_centroid:.6?})"),
        );
    }

    // ── 2. K-means k=3 partition comparison ─────────────────────────────────

    println!("\n=== K-means k=3 ===");

    let cfg3 = KMeansConfig::new(3, BandConstraint::Unconstrained)
        .unwrap()
        .with_n_init(10)
        .with_seed(42);
    let result3 = cfg3.fit(&series).unwrap();

    // Compare partitions (label-agnostic)
    let rust_assignments: Vec<usize> = result3.assignments.iter().map(|l| l.index()).collect();
    let rust_partition = partition_groups(&rust_assignments);

    // Build tslearn partition
    let mut py_partition: Vec<Vec<usize>> = ref_data
        .kmeans_k3
        .partition
        .values()
        .cloned()
        .collect();
    for g in &mut py_partition {
        g.sort();
    }
    py_partition.sort();

    let partition_match = rust_partition == py_partition;
    check_and_count(
        "k=3 partition",
        partition_match,
        &format!("rust={rust_partition:?}, py={py_partition:?}"),
    );

    // Compare inertia (tslearn normalizes by n, we don't).
    //
    // Inertia differs between implementations because DBA centroids converge to
    // slightly different values depending on inner iteration budget and tolerance.
    // Both find the same partition — the centroid quality just differs slightly.
    // We accept up to 25% relative difference and additionally verify that our
    // inertia is in the same order of magnitude.
    let py_inertia_unnormalized = ref_data.kmeans_k3.inertia; // manual sum(d²) from Python
    let rust_inertia = result3.inertia.value();
    let inertia_reldiff = (rust_inertia - py_inertia_unnormalized).abs()
        / py_inertia_unnormalized.max(1e-15);

    check_and_count(
        "k=3 inertia (same order)",
        inertia_reldiff < 0.25,
        &format!(
            "rust={rust_inertia:.6}, py={py_inertia_unnormalized:.6}, reldiff={inertia_reldiff:.2e} (DBA convergence diff expected)"
        ),
    );

    // Check cluster sizes: each cluster should have 3 members
    let sizes = result3.cluster_sizes();
    let mut sorted_sizes = sizes.clone();
    sorted_sizes.sort();
    let sizes_ok = sorted_sizes == vec![3, 3, 3];
    check_and_count(
        "k=3 cluster sizes",
        sizes_ok,
        &format!("{sizes:?}"),
    );

    // ── 3. K-means k=1 ─────────────────────────────────────────────────────

    println!("\n=== K-means k=1 ===");

    let cfg1 = KMeansConfig::new(1, BandConstraint::Unconstrained)
        .unwrap()
        .with_n_init(1)
        .with_seed(42);
    let result1 = cfg1.fit(&series).unwrap();

    // Inertia comparison
    let py_k1_inertia = ref_data.kmeans_k1.inertia;
    let rust_k1_inertia = result1.inertia.value();
    let k1_reldiff = (rust_k1_inertia - py_k1_inertia).abs() / py_k1_inertia.max(1e-15);
    check_and_count(
        "k=1 inertia",
        k1_reldiff < 0.01,
        &format!("rust={rust_k1_inertia:.4}, py={py_k1_inertia:.4}, reldiff={k1_reldiff:.4e}"),
    );

    // Centroid comparison
    let rust_k1_centroid: &[f64] = result1.centroids[0].as_ref();
    let py_k1_centroid = &ref_data.kmeans_k1.centroid;
    let k1_centroid_diff: f64 = rust_k1_centroid
        .iter()
        .zip(py_k1_centroid)
        .map(|(a, b)| (a - b).abs())
        .fold(0.0f64, f64::max);
    check_and_count(
        "k=1 centroid",
        k1_centroid_diff < 0.1,
        &format!("max_diff={k1_centroid_diff:.4e}"),
    );

    // ── 4. K-means k=9 (k=n) ───────────────────────────────────────────────

    println!("\n=== K-means k=9 (k=n) ===");

    let cfg9 = KMeansConfig::new(n, BandConstraint::Unconstrained)
        .unwrap()
        .with_n_init(1)
        .with_seed(42);
    let result9 = cfg9.fit(&series).unwrap();

    let py_k9_inertia = ref_data.kmeans_k9.inertia;
    let both_near_zero = result9.inertia.value() < 1e-6 && py_k9_inertia < 1e-6;
    check_and_count(
        "k=n inertia ≈ 0",
        both_near_zero,
        &format!("rust={:.2e}, py={:.2e}", result9.inertia.value(), py_k9_inertia),
    );

    // ── 5. Elbow sweep comparison ───────────────────────────────────────────

    println!("\n=== Elbow sweep k=1..9 ===");

    let opt_cfg = OptimizeConfig::new(1, n, BandConstraint::Unconstrained)
        .unwrap()
        .with_n_init(5)
        .with_seed(42);
    let opt_result = opt_cfg.fit(&series).unwrap();

    // Monotonicity: inertia should not increase with k
    let rust_inertias: Vec<f64> = opt_result.results.iter().map(|r| r.inertia.value()).collect();
    let monotone = rust_inertias
        .windows(2)
        .all(|w| w[1] <= w[0] * 1.01); // 1% tolerance for stochastic noise
    check_and_count("elbow monotonicity", monotone, &format!("{rust_inertias:.4?}"));

    // tslearn also normalizes elbow inertias by n; scale them up
    let py_elbow_inertias: Vec<f64> = ref_data.elbow.iter().map(|e| e.inertia * n as f64).collect();

    // Compare k=1 and k=9 endpoints between implementations
    let k1_elbow_reldiff = (rust_inertias[0] - py_elbow_inertias[0]).abs()
        / py_elbow_inertias[0].max(1e-15);
    check_and_count(
        "elbow k=1 inertia",
        k1_elbow_reldiff < 0.01,
        &format!(
            "rust={:.4}, py={:.4}, reldiff={k1_elbow_reldiff:.4e}",
            rust_inertias[0], py_elbow_inertias[0]
        ),
    );

    let last = rust_inertias.len() - 1;
    let k9_near_zero = rust_inertias[last] < 1e-6;
    check_and_count(
        "elbow k=9 inertia ≈ 0",
        k9_near_zero,
        &format!("{:.2e}", rust_inertias[last]),
    );

    // Both should identify k=3 as the elbow (biggest drop)
    let rust_best_k = opt_result.best_k();
    let py_best_k = {
        // Compute second derivative on tslearn data
        let inertias = &py_elbow_inertias;
        let mut best_idx = 1;
        let mut best_d2 = f64::NEG_INFINITY;
        for i in 1..inertias.len() - 1 {
            let d2 = inertias[i - 1] - 2.0 * inertias[i] + inertias[i + 1];
            if d2 > best_d2 {
                best_d2 = d2;
                best_idx = i;
            }
        }
        ref_data.elbow[best_idx].k
    };
    check_and_count(
        "elbow best_k",
        rust_best_k == Some(py_best_k),
        &format!("rust={rust_best_k:?}, py={py_best_k}"),
    );

    // ── Summary ─────────────────────────────────────────────────────────────

    println!("\n{}", "=".repeat(60));
    println!("  {n_pass} passed, {n_fail} failed\n");

    if n_fail > 0 {
        std::process::exit(1);
    }
}
